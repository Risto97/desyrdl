library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.pkg_types.all;

package pkg_reg_{modname} is

  -----------------------------------------------
  -- below: common declarations
  -----------------------------------------------

  --type t_field_access is (R, W, RW, NA);
  subtype t_field_access is integer;
  constant C_RW  : integer := 2;
  constant C_RW1 : integer := 5;
  constant C_R   : integer := 3;
  constant C_W   : integer := 4;
  constant C_W1  : integer := 6;
  constant C_NA  : integer := 1;

  type t_field_type is (STORAGE, WIRE, COUNTER, INTERRUPT);

  type t_field_info is record
    ftype : t_field_type;
    len   : integer;
    upper : integer;
    lower : integer;
    hw_we : boolean;
    sw_access : t_field_access;
    hw_access : t_field_access;
    def_val : std_logic_vector(32-1 downto 0);
    incrwidth : integer;
    decrwidth : integer;
  end record;
  type t_field_info_arr is array (integer range 31 downto 0) of t_field_info;
  constant C_FIELD_NONE : t_field_info := (WIRE, 0, 0, 0, false, C_NA, C_NA, (others => '0'), 0, 0);

  type t_field_signals_in is record
    data : std_logic_vector; -- VHDL-2008 - check if Vivado can simulate this
    we : std_logic;
    incr : std_logic;
    decr : std_logic;
  end record;

  type t_field_signals_out is record
    data : std_logic_vector; -- VHDL-2008 - and if ISE can work with this
    swacc : std_logic;
    swmod : std_logic;
  end record;

  constant C_ADDR_W : integer := 32;

  type t_mem_in is record
    ena  : std_logic;
    wr   : std_logic;
    addr : std_logic_vector(C_ADDR_W-2-1 downto 0);
    data : std_logic_vector(32-1 downto 0);
  end record t_mem_in;
  type t_mem_in_arr is array (natural range <>) of t_mem_in;

  -- TODO make this a record as well just to stay consistent
  subtype t_mem_out is std_logic_vector(32-1 downto 0);
  type t_mem_out_arr is array (natural range <>) of t_mem_out;

  -----------------------------------------------
  -- below: per regfile / module !
  -----------------------------------------------

  -- must be calculated by register tool
  -- always add +1 for the dummy
  constant C_REGTYPES  : integer := {n_regtypes};
  constant C_REGNAMES : integer := {n_regnames};
  constant C_REGCOUNT : integer := {n_regcount};
  constant C_MEMNAMES : integer := {n_memnames};
  -- TODO C_MEMCOUNT
  constant C_MEM_INTERNAL : T_IntegerArray(C_MEMNAMES downto 0) := (others => 1); -- TODO
  -- memory address width must be less than or equal to C_ADDR_W-2
  -- TODO C_MEMCOUNT
  constant C_MEM_AW : T_IntegerArray(C_MEMNAMES downto 0) := (
    -- divide by four for addressing 32-bit elements
    --{memnames:repeat:memnames:
    {{i}} => {{aw}}, -- {{mem.inst_name}}}
    C_MEMNAMES => 0 -- dummy
  );
  -- The two numbers below must both be a multiple of 4 (for 32 bit addresses)
  constant C_MEM_START : T_IntegerArray(C_MEMNAMES downto 0) := (
    --{memnames:repeat:memnames:
    {{i}} => {{mem.address_offset}}, -- {{mem.inst_name}}}
    C_MEMNAMES => 0 -- dummy
  );

  constant C_EXTNAMES : integer := {n_extnames};
  constant C_EXTCOUNT : integer := C_EXTNAMES;
  constant C_EXT_AW : T_IntegerArray(C_EXTNAMES downto 0) := (
    -- divide by four for addressing 32-bit elements FIXME ceil(x/4)
    --{extnames:repeat:extnames:
    {{i}} => {{aw}}, -- {{ext.inst_name}}}
    C_EXTNAMES => 0 -- dummy
  );
  -- The two numbers below must both be a multiple of 4 (for 32 bit addresses)
  constant C_EXT_START : T_IntegerArray(C_EXTNAMES downto 0) := (
    --{extnames:repeat:extnames:
    {{i}} => {{ext.address_offset}}, -- {{ext.inst_name}}}
    C_EXTNAMES => 0 -- dummy
  );

  -- register types

  type t_regtype is (
    --{regtypes:repeat:regtypes:
    {{regtype.type_name}}, --}
    NONE -- dummy
  );

  type t_reg_info is record
    addr    : integer;
    base    : integer;
    regtype : t_regtype;
    fields  : t_field_info_arr;
    N       : positive;
    M       : positive;
  end record;
  -- Maybe better to constrain t_reg_info_array. Vivado shows weird indices when unconstrained.
  -- Must be the number of distinct register names, not one for each 2D/3D array element!
  type t_reg_info_array is array (0 to C_REGNAMES) of t_reg_info;
  constant C_REG_NONE : t_reg_info := (0, 0, NONE, (others => C_FIELD_NONE), 1, 1);

  --{regtypes:repeat:regtypes:
  constant C_{{regtype.type_name:upper}}_FIELDS : t_field_info_arr := (
    --{{regtype:repeat:fields:
    {{{{i}}}} => (ftype => {{{{field:ftype}}}}, len => {{{{field.width}}}}, upper => {{{{field.high}}}}, lower => {{{{field.low}}}}, hw_we => {{{{hw_we}}}}, sw_access => C_{{{{sw_access:upper}}}}, hw_access => C_{{{{hw_access:upper}}}},  def_val => {{{{reset}}}}, decrwidth => {{{{decrwidth}}}}, incrwidth => {{{{incrwidth}}}}), -- {{{{field.inst_name}}}} --}}
    others => C_FIELD_NONE
  );

  --}

  constant C_REGISTER_INFO : t_reg_info_array := (
    --{regnames:repeat:regnames:
    {{i}} => (addr => {{reg.address_offset}}, base => {{base}}, regtype => {{reg.type_name}}, fields => C_{{reg.type_name:upper}}_FIELDS, N => {{N}}, M => {{M}}), --}
    others => C_REG_NONE
  );

  --{regtypes:repeat:regtypes:
  -----------------------------------------------
  -- register type: {{regtype.type_name}}
  -----------------------------------------------
  -- contains up to 32 data bits plus the other signals (we, incr, ..)
  type t_reg_{{regtype.type_name}}_in is record
    -- fields
    --{{regtype:repeat:fields:
    {{{{field.type_name}}}} : t_field_signals_in(data(C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).len-1 downto 0)); --}}
  end record;
  type t_reg_{{regtype.type_name}}_3d_in is array (integer range <>, integer range <>) of t_reg_{{regtype.type_name}}_in;

  type t_reg_{{regtype.type_name}}_out is record
    -- fields
    --{{regtype:repeat:fields:
    {{{{field.type_name}}}} : t_field_signals_out(data(C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).len-1 downto 0)); --}}
  end record;
  type t_reg_{{regtype.type_name}}_3d_out is array (integer range <>, integer range <>) of t_reg_{{regtype.type_name}}_out;

  --}

  -----------------------------------------------
  -- module I/O types: {modname}
  -----------------------------------------------
  -- TODO generate external interface if that attribute is set
  type t_registers_{modname}_in is record
    --{regnames:repeat:regnames:
    {{reg.inst_name}} : t_reg_{{reg.type_name}}_3d_in(0 to C_REGISTER_INFO({{i}}).N-1, 0 to C_REGISTER_INFO({{i}}).M-1); --}
    NONE : std_logic;
  end record;

  type t_registers_{modname}_out is record
    --{regnames:repeat:regnames:
    {{reg.inst_name}} : t_reg_{{reg.type_name}}_3d_out(0 to C_REGISTER_INFO({{i}}).N-1, 0 to C_REGISTER_INFO({{i}}).M-1); --}
    NONE : std_logic;
  end record;

  type t_memories_{modname}_out is record
    --{memnames:repeat:memnames:
    {{mem.inst_name}}     : t_mem_out; --}
    NONE : t_mem_out;
  end record;

  type t_memories_{modname}_in is record
    --{memnames:repeat:memnames:
    {{mem.inst_name}}     : t_mem_in; --}
    NONE : t_mem_in;
  end record;

  --{regtypes:repeat:regtypes:
  -----------------------------------------------
  -- register type functions: {{regtype.type_name}}
  -----------------------------------------------
  function fun_slv_to_{{regtype.type_name}} (slv : std_logic_vector(32-1 downto 0); swmod : std_logic_vector(32-1 downto 0); swacc : std_logic_vector(32-1 downto 0)) return t_reg_{{regtype.type_name}}_out;
  function fun_{{regtype.type_name}}_to_data (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector;
  function fun_{{regtype.type_name}}_to_decr (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector;
  function fun_{{regtype.type_name}}_to_incr (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector;
  function fun_{{regtype.type_name}}_to_we   (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector;
  --}

end package pkg_reg_{modname};

package body pkg_reg_{modname} is

  --{regtypes:repeat:regtypes:
  -----------------------------------------------
  -- register type: {{regtype.type_name}}
  -----------------------------------------------
  -- unpack
  function fun_slv_to_{{regtype.type_name}} (slv : std_logic_vector(32-1 downto 0); swmod : std_logic_vector(32-1 downto 0); swacc : std_logic_vector(32-1 downto 0)) return t_reg_{{regtype.type_name}}_out is
    variable v_tmp : t_reg_{{regtype.type_name}}_out;
  begin
    --{{regtype:repeat:fields:
    v_tmp.{{{{field.type_name}}}}.data := slv(C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).upper downto C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).lower);
    v_tmp.{{{{field.type_name}}}}.swmod := swmod({{{{i}}}});
    v_tmp.{{{{field.type_name}}}}.swacc := swacc({{{{i}}}}); --}}

    return v_tmp;
  end function;

  -- pack
  function fun_{{regtype.type_name}}_to_data (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    --{{regtype:repeat:fields:
    v_tmp(C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).upper downto C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).lower) := reg.{{{{field.type_name}}}}.data; --}}

    return v_tmp;
  end function;

  function fun_{{regtype.type_name}}_to_decr (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    --{{regtype:repeat:fields:
    v_tmp({{{{i}}}}) := reg.{{{{field.type_name}}}}.decr ; -- FIXME? --}}

    return v_tmp;
  end function;

  function fun_{{regtype.type_name}}_to_incr (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    --{{regtype:repeat:fields:
    v_tmp({{{{i}}}}) := reg.{{{{field.type_name}}}}.incr; --}}

    return v_tmp;
  end function;

  function fun_{{regtype.type_name}}_to_we (reg : t_reg_{{regtype.type_name}}_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    --{{regtype:repeat:fields:
    v_tmp({{{{i}}}}) := reg.{{{{field.type_name}}}}.we when C_{{{{field.parent.type_name:upper}}}}_FIELDS({{{{i}}}}).hw_we else '0'; -- FIXME VHDL-2008? --}}

    return v_tmp;
  end function;

  --}
  -- END duplicate for each regtype

end package body;
