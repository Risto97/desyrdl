library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.pkg_types.all;

package pkg_reg_<modname> is

  -----------------------------------------------
  -- below: common declarations
  -----------------------------------------------

  --type t_field_access is (R, W, RW, NA);
  subtype t_field_access is std_logic_vector(1 downto 0);
  constant C_RW : std_logic_vector(1 downto 0) := "11";
  constant C_R  : std_logic_vector(1 downto 0) := "10";
  constant C_W  : std_logic_vector(1 downto 0) := "01";
  constant C_NA : std_logic_vector(1 downto 0) := "00";

  type t_field_type is (STORAGE, WIRE, COUNTER, INTERRUPT);

  type t_field_info is record
    ftype : t_field_type;
    len   : integer;
    upper : integer;
    lower : integer;
    hw_we : boolean;
    sw_access : t_field_access;
    hw_access : t_field_access;
    def_val : std_logic_vector(32-1 downto 0);
  end record;
  type t_field_info_arr is array (integer range 31 downto 0) of t_field_info;
  constant C_FIELD_NONE : t_field_info := (WIRE, 0, 0, 0, false, C_NA, C_NA, (others => '0'));

  type t_field_signals_in is record
    data : std_logic_vector; -- VHDL-2008 - check if Vivado can simulate this
    we : std_logic;
    incr : std_logic;
    decr : std_logic;
  end record;

  type t_field_signals_out is record
    data : std_logic_vector; -- VHDL-2008 - and if ISE can work with this
    swacc : std_logic;
    swmod : std_logic;
  end record;

  -----------------------------------------------
  -- below: per regfile / module !
  -----------------------------------------------

  constant C_ADDR_W : integer := 8;

--  type t_dpm_list is record
--    base_array : t_IntegerArray(0 to C_MEMORIES-1);
--    width_array : t_IntegerArray(0 to C_MEMORIES-1);
--  end record t_dpm_list;
--
--  constant C_DPM_ARRAY : t_dpm_list := (
--    (C_ADDR_AREA_SIN, C_ADDR_AREA_COS),
--    (C_WIDTH_AREA_SIN, C_WIDTH_AREA_COS)
--  );
--
--  type t_dpm_array_i is record
--    ena  : std_logic;
--    wr   : std_logic;
--    addr : std_logic_vector(C_ADDR_W-1 downto 0);
--    data : std_logic_vector(32-1 downto 0);
--  end record t_dpm_array;

  -- must be calculated by register tool
  constant C_REGNAMES  : integer := <regname_count>;
  constant C_REGISTERS : integer := <reg_count>;

  -- register types

  type t_regtype is (
    -- BEGIN duplicate for each regtype
    <regtype>,
    -- END duplicate for each regtype
    DUMMY -- just for having no comma at the end here..
  );

  type t_reg_info is record
    addr    : integer;
    base    : integer;
    regtype : t_regtype;
    fields  : t_field_info_arr;
    N       : positive;
    M       : positive;
  end record;
  -- Maybe better to constrain t_reg_info_array. Vivado shows weird indices when unconstrained.
  -- Must be the number of distinct register names, not one for each 2D/3D array element!
  type t_reg_info_array is array (0 to C_REGNAMES-1) of t_reg_info;

  -- BEGIN duplicate for each regtype
  constant C_<REGTYPE>_INFO : t_field_info_arr := (
    -- BEGIN duplicate for each field of <regtype>
    <i> => (ftype => <ftype>, len => <len>, upper => <upper>, lower => <lower>, hw_we => <hw_we>, sw_access => <sw_access>, hw_access => <hw_access>,  def_val => <def_val>), -- <field>
    -- END duplicate for each field
    others => C_FIELD_NONE
  );
  -- END duplicate for each regtype

  constant C_REGISTER_INFO : t_reg_info_array := (
    -- BEGIN duplicate for each regname
    <i> => (addr => <addr>, base => <base>, regtype => <REGTYPE>, fields => C_<REGTYPE>_INFO, N => <N>, M => <M>),
    -- END duplicate for each regname
  );

  -- BEGIN duplicate for each regtype
  -----------------------------------------------
  -- register type: <regtype>
  -----------------------------------------------
  -- contains up to 32 data bits plus the other signals (we, incr, ..)
  type t_reg_<regtype>_in is record
    -- fields
    -- BEGIN duplicate for each field of <regtype>
    <field> : t_field_signals_in(data(C_<REGTYPE>_INFO(<i>).len-1 downto 0));
    -- END duplicate for each field
  end record;
  type t_reg_<regtype>_3d_in is array (integer range <>, integer range <>) of t_reg_<regtype>_in;

  type t_reg_<regtype>_out is record
    -- fields
    -- BEGIN duplicate for each field of <regtype>
    <field> : t_field_signals_out(data(C_<REGTYPE>_INFO(<i>).len-1 downto 0));
    -- END duplicate for each field
  end record;
  type t_reg_<regtype>_3d_out is array (integer range <>, integer range <>) of t_reg_<regtype>_out;
  -- END duplicate for each regtype

  -----------------------------------------------
  -- module I/O types: <modname>
  -----------------------------------------------
  type t_registers_<modname>_in is record
    -- BEGIN duplicate for each regname
    <regname> : t_reg_<regtype>_3d_in(0 to C_REGISTER_INFO(<i>).N-1, 0 to C_REGISTER_INFO(<i>).M-1);
    -- END duplicate for each regname
  end record;

  type t_registers_<modname>_out is record
    -- BEGIN duplicate for each regname
    <regname> : t_reg_<regtype>_3d_out(0 to C_REGISTER_INFO(<i>).N-1, 0 to C_REGISTER_INFO(<i>).M-1);
    -- END duplicate for each regname
  end record;

  -- BEGIN duplicate for each regtype
  -----------------------------------------------
  -- register type functions: <regtype>
  -----------------------------------------------
  function fun_slv_to_<regtype> (slv : std_logic_vector(32-1 downto 0)) return t_reg_<regtype>_out;
  function fun_<regtype>_to_data (reg : t_reg_<regtype>_in) return std_logic_vector;
  function fun_<regtype>_to_decr (reg : t_reg_<regtype>_in) return std_logic_vector;
  function fun_<regtype>_to_incr (reg : t_reg_<regtype>_in) return std_logic_vector;
  function fun_<regtype>_to_we   (reg : t_reg_<regtype>_in) return std_logic_vector;
  -- END duplicate for each regtype

end package pkg_reg_<modname>;

package body pkg_reg_<modname> is

  -- BEGIN duplicate for each regtype
  -----------------------------------------------
  -- register type: <regtype>
  -----------------------------------------------
  -- unpack
  function fun_slv_to_<regtype> (slv : std_logic_vector(32-1 downto 0)) return t_reg_<regtype>_out is
    variable v_tmp : t_reg_<regtype>_out;
  begin
    -- BEGIN duplicate for each field of <regtype>
    v_tmp.<field>.data := slv(C_<REGTYPE>_INFO(<i>).upper downto C_<REGTYPE>_INFO(<i>).lower);
    -- END duplicate for each field

    return v_tmp;
  end function;

  -- pack
  function fun_<regtype>_to_data (reg : t_reg_<regtype>_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    -- BEGIN duplicate for each field of <regtype>
    v_tmp(C_<REGTYPE>_INFO(<i>).upper downto C_<REGTYPE>_INFO(<i>).lower) := reg.<field>.data;
    -- END duplicate for each field

    return v_tmp;
  end function;

  function fun_<regtype>_to_decr (reg : t_reg_<regtype>_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    -- BEGIN duplicate for each field of <regtype>
    v_tmp(<i>) := reg.<field>.decr ; -- FIXME?
    -- END duplicate for each field

    return v_tmp;
  end function;

  function fun_<regtype>_to_incr (reg : t_reg_<regtype>_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    -- BEGIN duplicate for each field of <regtype>
    v_tmp(<i>) := reg.<field>.incr when C_<REGTYPE>_INFO(<i>).hw_we else '0'; -- FIXME
    -- END duplicate for each field

    return v_tmp;
  end function;

  function fun_<regtype>_to_we (reg : t_reg_<regtype>_in) return std_logic_vector is
    variable v_tmp : std_logic_vector(32-1 downto 0);
  begin
    -- BEGIN duplicate for each field of <regtype>
    v_tmp(<i>) := reg.<field>.we when C_<REGTYPE>_INFO(<i>).hw_we else '0';
    -- END duplicate for each field

    return v_tmp;
  end function;
  -- END duplicate for each regtype

end package body;
