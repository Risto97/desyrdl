-- Copyright (c) 2020-2021 Deutsches Elektronen-Synchrotron DESY.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library desyrdl;
use desyrdl.common.all;
use desyrdl.pkg_{node.type_name}.all;

-- library desy;
-- use desy.common_axi.all;

entity {node.type_name} is
  port (
    pi_clock : in std_logic;
    pi_reset : in std_logic;
    -- TOP subordinate memory mapped interface
    pifi_s_top  : in  tif_{node.type_name}_m2s;
    pifo_s_top  : out tif_{node.type_name}_s2m;
    -- pifi_s_top  : in  tif_{desyrdl_interface:lower}_m2s;
    -- pifo_s_top  : out tif_{desyrdl_interface:lower}{desyrdl_interface:lower}_s2m;
    -- to logic interface
    pifi_addrmap : in  tif_addrmap_{node.type_name}_in;
    pifo_addrmap : out tif_addrmap_{node.type_name}_out
  );
end entity {node.type_name};

architecture arch of {node.type_name} is

  type t_data_out is array (natural range<>) of std_logic_vector(C_DATA_WIDTH-1 downto 0) ;
  signal reg_data_out_vect : t_data_out({n_regcount}-1 downto 0);

  signal reg_rd_stb   : std_logic_vector({n_regcount}-1 downto 0);
  signal reg_wr_stb   : std_logic_vector({n_regcount}-1 downto 0);
  signal reg_data_out : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal reg_data_in  : std_logic_vector(C_DATA_WIDTH-1 downto 0);

  signal mem_data_out_vect : t_data_out({n_memitems}-1 downto 0);
  signal mem_stb      : std_logic_vector({n_memitems}-1 downto 0);
  signal mem_we       : std_logic;
  signal mem_addr     : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal mem_data_out : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal mem_data_in  : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal mem_ack      : std_logic;

  signal ifi_ext      : tif_{desyrdl_interface:lower}_s2m_array({n_extitems} downto 0);
  signal ifo_ext      : tif_{desyrdl_interface:lower}_m2s_array({n_extitems} downto 0);

begin

  inst_decoder_axi4l: entity desyrdl.decoder_{desyrdl_interface:lower}
    generic map (
      g_addr_width    => C_ADDR_WIDTH,
      g_data_width    => C_DATA_WIDTH,
      g_register_info => C_REGISTER_INFO,
      g_regitems      => {n_regitems},
      g_regcount      => {n_regcount},
      g_mem_info      => C_MEM_INFO,
      g_memitems      => {n_memitems},
      g_memcount      => {n_memitems},
      g_ext_info      => C_EXT_INFO,
      g_extitems      => {n_extitems},
      g_extcount      => {n_extitems}
    )
    port map (
      pi_clock      => pi_clock,
      pi_reset      => pi_reset,

      po_reg_rd_stb => reg_rd_stb,
      po_reg_wr_stb => reg_wr_stb,
      po_reg_data   => reg_data_in,
      pi_reg_data   => reg_data_out,
      po_mem_stb    => mem_stb,
      po_mem_we     => mem_we,
      po_mem_addr   => mem_addr,
      po_mem_data   => mem_data_in,
      pi_mem_data   => mem_data_out,
      pi_mem_ack    => mem_ack,

      pifi_ext      => ifi_ext,
      pifo_ext      => ifo_ext,

      pifi_s_top    => pifi_s_top,
      pifo_s_top    => pifo_s_top
    );

  prs_reg_rd_mux: process(pi_clock)
  begin
    if rising_edge(pi_clock) then
      for idx in 0 to {n_regcount}-1 loop
        if reg_rd_stb(idx) = '1' then
          reg_data_out <= reg_data_out_vect(idx);
        end if;
      end loop;
    end if;
  end process prs_reg_rd_mux;

  prs_mem_rd_mux: process(pi_clock)
  begin
    if rising_edge(pi_clock) then
      for idx in 0 to {n_memitems}-1 loop
        if mem_stb(idx) = '1' then
          mem_data_out <= mem_data_out_vect(idx);
        end if;
      end loop;
    end if;
  end process prs_mem_rd_mux;

  -- ===========================================================================
  -- generated registers instances{regitems:repeat:
  -- ---------------------------------------------------------------------------
  -- reg name: {{reg.inst_name}}  reg type: {{reg.type_name}}
  -- ---------------------------------------------------------------------------
  blk_{{i}}_{{name}} : block
  begin  --{{context:if:eq:dim:1:
    inst_{{name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
      port map(
        pi_clock        => pi_clock,
        pi_reset        => pi_reset,
        -- to/from adapter
        pi_decoder_rd_stb => reg_rd_stb({{index}}),
        pi_decoder_wr_stb => reg_wr_stb({{index}}),
        pi_decoder_data   => reg_data_in,
        po_decoder_data   => reg_data_out_vect({{index}}),

        pifi_reg  => pifi_addrmap.{{{{reg.inst_name}}}},
        pifo_reg  => pifo_addrmap.{{{{reg.inst_name}}}}
      );--}} --{{context:if:eq:dim:2:
    gen_m: for idx_m in 0 to {{dim_m}}-1 generate
      inst_{{name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
        port map(
          pi_clock        => pi_clock,
          pi_reset        => pi_reset,
          -- to/from adapter
          pi_decoder_rd_stb => reg_rd_stb({{index}}+idx_m),
          pi_decoder_wr_stb => reg_wr_stb({{index}}+idx_m),
          pi_decoder_data   => reg_data_in,
          po_decoder_data   => reg_data_out_vect({{index}}+idx_m),

          pifi_reg  => pifi_addrmap.{{{{reg.inst_name}}}}(idx_m),
          pifo_reg  => pifo_addrmap.{{{{reg.inst_name}}}}(idx_m)
        );
    end generate;--}} --{{context:if:eq:dim:3:
    gen_n : for idx_n in 0 to {{dim_n}}-1 generate  -- outer dim, for 3D arrays
      gen_m: for idx_m in 0 to {{dim_m}}-1 generate -- inner dim, for 2D arrays
        constant l_idx : natural := (idx_m + 1) * (idx_n + 1) - 1 ;
      begin
        inst_{{reg.inst_name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
          port map(
            pi_clock        => pi_clock,
            pi_reset        => pi_reset,
            -- to/from adapter
            pi_decoder_rd_stb => reg_rd_stb({{index}}+l_idx),
            pi_decoder_wr_stb => reg_wr_stb({{index}}+l_idx),
            pi_decoder_data   => reg_data_in,
            po_decoder_data   => reg_data_out_vect({{index}}+l_idx),

            pifi_reg  => pifi_addrmap.{{{{reg.inst_name}}}}(idx_n,idx_m),
            pifo_reg  => pifo_addrmap.{{{{reg.inst_name}}}}(idx_n,idx_m)
          );
      end generate;
    end generate;--}}
  end block; --}

  -- ===========================================================================
  --{memitems:repeat:
  -- ---------------------------------------------------------------------------
  -- mem name: {{mem.inst_name}}  mem type: {{mem.type_name}}
  -- ---------------------------------------------------------------------------
  blk_{{i}}_{{name}} : block
  begin
    mem_ack <= '1';
    mem_data_out_vect({{i}})({{datawidth}}-1 downto 0) <= pifi_addrmap.{{mem.inst_name}}.data;{{context:if:lt:datawidth:32:
    mem_data_out_vect({{{{i}}}})(C_DATA_WIDTH-1 downto {{{{datawidth}}}}) <= (others => '0');}}
    pifo_addrmap.{{mem.inst_name}}.addr <= mem_addr({{addrwidth}}-1 downto 0);
    pifo_addrmap.{{mem.inst_name}}.data <= mem_data_in({{datawidth}}-1 downto 0);
    pifo_addrmap.{{mem.inst_name}}.en <= mem_stb({{i}});
    pifo_addrmap.{{mem.inst_name}}.we <= mem_we;
  end block;
  --}

  -- ===========================================================================
  --{extitems:repeat:
  -- ---------------------------------------------------------------------------
  -- ext name: {{ext.inst_name}}  ext type: {{ext.type_name}}
  -- ---------------------------------------------------------------------------
  blk_{{i}}_{{ext.inst_name}} : block
  begin
    ins_{desyrdl_interface:lower}_to_{{desyrdl_interface:lower}} : entity desyrdl.{desyrdl_interface:lower}_to_{{desyrdl_interface:lower}}
      port map (
        pi_clock => pi_clock,
        pi_reset => pi_reset,
        pifi_s_decoder => ifo_ext({{i}}),
        pifo_s_decoder => ifi_ext({{i}}),
        pifo_m_ext     => pifo_addrmap.{{ext.inst_name}},
        pifi_m_ext     => pifi_addrmap.{{ext.inst_name}}
      );
  end block;
  --}

end architecture;
