-- Copyright (c) 2020-2021 Deutsches Elektronen-Synchrotron DESY.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.pkg_types.all;
use work.pkg_axi.all;
use work.pkg_reg_common.all;
use work.pkg_reg_{context[node].type_name}.all;

entity top_reg_{context[node].type_name} is
  port (
    pi_clock           : in std_logic;
    pi_reset         : in std_logic;

    -- AXI4
    pi_s_axi4 : in  t_axi4_m2s;
    po_s_axi4 : out t_axi4_s2m;

    -- logic
    pi_addrmap : in t_addrmap_{context[node].type_name}_in;
    po_addrmap : out t_addrmap_{context[node].type_name}_out

  );
end entity top_reg_{context[node].type_name};

architecture arch of top_reg_{context[node].type_name} is
  signal adapter_stb : std_logic_vector(C_REGCOUNT-1 downto 0);
  signal adapter_we  : std_logic;
  signal adapter_err : std_logic;
  signal adapter_wdata : std_logic_vector(32-1 downto 0);
  signal adapter_rdata : t_32BitArray(C_REGCOUNT-1 downto 0);

  signal adapter_from_dpm : t_mem_out_arr(C_MEMNAMES downto 0);
  signal adapter_to_dpm : t_mem_in_arr(C_MEMNAMES downto 0);

  signal adapter_from_ext : t_axi4_s2m_array(C_EXTCOUNT downto 0);
  signal adapter_to_ext : t_axi4_m2s_array(C_EXTCOUNT downto 0);

begin
  ins_adapter: entity work.adapter_axi4
  generic map (
                G_ADDR_W     => C_ADDR_W,
                G_REGISTER_INFO => C_REGISTER_INFO,
                G_MEMNAMES   => C_MEMNAMES,
                G_MEM_START  => C_MEM_START,
                G_MEM_AW     => C_MEM_AW,
                G_EXTCOUNT   => C_EXTCOUNT,
                G_EXT_START  => C_EXT_START,
                G_EXT_SIZE   => C_EXT_SIZE,
                G_EXT_AW     => C_EXT_AW,
                G_REGNAMES   => C_REGNAMES,
                G_REGCOUNT   => C_REGCOUNT
              )
  port map (
             pi_regs       => adapter_rdata,
             po_stb        => adapter_stb,
             po_we         => adapter_we,
             pi_err        => adapter_err,
             po_data       => adapter_wdata,
             clk           => pi_clock,
             reset         => pi_reset,

             po_mem        => adapter_to_dpm,
             pi_mem        => adapter_from_dpm,

             po_ext        => adapter_to_ext(C_EXTCOUNT downto 0),
             pi_ext        => adapter_from_ext(C_EXTCOUNT downto 0),

             S_AXI_AWADDR  => pi_s_axi4.awaddr(C_ADDR_W-1 downto 0),
             S_AXI_AWPROT  => (others => '0'),
             S_AXI_AWVALID => pi_s_axi4.awvalid,
             S_AXI_AWREADY => po_s_axi4.awready,
             S_AXI_AWID    => pi_s_axi4.awid,
             S_AXI_WDATA   => pi_s_axi4.wdata(32-1 downto 0),
             S_AXI_WSTRB   => pi_s_axi4.wstrb(4-1 downto 0),
             S_AXI_WVALID  => pi_s_axi4.wvalid,
             S_AXI_WREADY  => po_s_axi4.wready,
             S_AXI_BRESP   => po_s_axi4.bresp,
             S_AXI_BVALID  => po_s_axi4.bvalid,
             S_AXI_BREADY  => pi_s_axi4.bready,
             S_AXI_BID     => po_s_axi4.bid,
             S_AXI_ARADDR  => pi_s_axi4.araddr(C_ADDR_W-1 downto 0),
             S_AXI_ARPROT  => (others => '0'),
             S_AXI_ARVALID => pi_s_axi4.arvalid,
             S_AXI_ARREADY => po_s_axi4.arready,
             S_AXI_ARID    => pi_s_axi4.arid,
             S_AXI_RDATA   => po_s_axi4.rdata(32-1 downto 0),
             S_AXI_RRESP   => po_s_axi4.rresp,
             S_AXI_RVALID  => po_s_axi4.rvalid,
             S_AXI_RREADY  => pi_s_axi4.rready,
             S_AXI_RID     => po_s_axi4.rid
           );

  -- external interfaces (if present) {context:ifgtzero:n_extnames:
  -- downstream interface assignments
  blk_ext_ports : block
  begin
  --{{context:repeat:extnames:
    po_addrmap.{{{{ext.inst_name}}}} <= adapter_to_ext({{{{i}}}});
    adapter_from_ext({{{{i}}}}) <= pi_addrmap.{{{{ext.inst_name}}}}; --}}
  end block;
  --}

  po_s_axi4.aclk <= pi_clock;
  po_s_axi4.rlast <= '1';

  -- memory assignments
  --
  -- TODO implement arrays of memories? DeviceAccess couldn't handle,
  -- rely on separate instances for now.
  blk_mem_ports : block
  begin
  --{context:repeat:memnames:
    po_addrmap.{{mem.inst_name}}.ena  <= adapter_to_dpm({{i}}).ena;
    po_addrmap.{{mem.inst_name}}.wr   <= adapter_to_dpm({{i}}).wr;
    po_addrmap.{{mem.inst_name}}.addr <= adapter_to_dpm({{i}}).addr({{aw}}-1 downto 0);
    po_addrmap.{{mem.inst_name}}.data <= adapter_to_dpm({{i}}).data({{memwidth}}-1 downto 0);
    adapter_from_dpm({{i}})({{memwidth}}-1 downto 0) <= pi_addrmap.{{mem.inst_name}}; --}
  end block;

  --{context:repeat:regnames:
  -- regname {{reg.inst_name}} regtype {{reg.type_name}}
  blk_{{i}}_{{reg.inst_name}} : block
    constant l_r : integer := {{i}};
    constant l_reg_info : t_reg_info := C_REGISTER_INFO(l_r);
  begin
    gen_N : for i in 0 to l_reg_info.N-1 generate  -- outer dim, for 3D arrays
    begin
      gen_M: for j in 0 to l_reg_info.M-1 generate -- inner dim, for 2D arrays
        signal l_reg_incr     : std_logic_vector(32-1 downto 0);
        signal l_reg_decr     : std_logic_vector(32-1 downto 0);
        signal l_reg_we       : std_logic_vector(32-1 downto 0);
        signal l_reg_data_in  : std_logic_vector(32-1 downto 0);
        signal l_reg_data_out : std_logic_vector(32-1 downto 0);
        signal l_reg_swmod    : std_logic_vector(32-1 downto 0);
        signal l_reg_swacc    : std_logic_vector(32-1 downto 0);
      begin

        -- signal assignments have to be done with generated functions
        l_reg_incr    <= fun_{{reg.type_name}}_to_incr(pi_addrmap.{{reg.inst_name}}(i,j));
        l_reg_decr    <= fun_{{reg.type_name}}_to_decr(pi_addrmap.{{reg.inst_name}}(i,j));
        l_reg_we      <= fun_{{reg.type_name}}_to_we(  pi_addrmap.{{reg.inst_name}}(i,j));
        l_reg_data_in <= fun_{{reg.type_name}}_to_data(pi_addrmap.{{reg.inst_name}}(i,j));
        po_addrmap.{{reg.inst_name}}(i,j) <= fun_slv_to_{{reg.type_name}}(l_reg_data_out, l_reg_swmod, l_reg_swacc);

        -- TODO implement swacc
        l_reg_swacc <= (others => '0');

        ins_reg: entity work.desy_register
        generic map (
                      -- contains an array of field info
                      g_fields => l_reg_info.fields
                    )
        port map (
                   pi_clock => pi_clock,
                   pi_reset => pi_reset,

                   -- to/from adapter
                   pi_adapter_stb  => adapter_stb(l_reg_info.base+i*l_reg_info.M+j),
                   pi_adapter_we   => adapter_we,
                   po_adapter_err  => adapter_err,
                   pi_adapter_data => adapter_wdata,
                   po_adapter_data => adapter_rdata(l_reg_info.base+i*l_reg_info.M+j),

                   -- to/from our IP
                   pi_logic_incr => l_reg_incr,
                   pi_logic_decr => l_reg_decr,
                   pi_logic_we   => l_reg_we,
                   pi_logic_data => l_reg_data_in,
                   po_logic_data => l_reg_data_out,
                   po_logic_swmod => l_reg_swmod
                 );

      end generate;
    end generate;
  end block;

  --}

end architecture;

