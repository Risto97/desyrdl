= Context for template processing

== Requirements

=== common

* type of addrmap (goes to names of entities and types)
** also needed below `ifgtzero` so must be part of context
* instance name is NOT needed here, just in the higher-level addrmap

=== registers

* for mapfile
** regnames
*** addrmap: the parent address map instance name, e.g. APP or BSP or TIMING
*** reg.inst_name
*** M (mapfile only supports one array dimension)
*** addr: absolute_address minus the offset of the BAR
*** reg.total_size: must be M*4 because accesses from SW are spaced by 4 bytes
*** bar: property of the addrmap below top (BSP or APP)
*** regwidth: number of bits that a single register uses (up to 32)
*** rw: either "RW" or "RO"
* for pkg
** n_regnames -> C_REGNAMES -> adapter_axi4
** n_regcount -> C_REGCOUNT -> adapter_axi4, top
** regtypes: list of nodes with individual type_name
*** type_name:upper
*** fields of that type
**** i
**** inst_name
**** field:ftype
**** field.width
**** field.high
**** field.low
**** hw_we
**** sw_access (t_field_access) = `field.get_property("sw").name`
**** hw_access (t_field_access) = `field.get_property("hw").name`
**** reset (default value after reset)
**** decrwidth
**** incrwidth
** regnames: instances of a regtype, can be single instance or array
*** index
*** base: this weird other index that the adapter needs for address decoding
*** type_name:upper
*** inst_name
*** addr: absolute_address minus the offset of the BAR
*** N, M: to have it in C_REGISTER_INFO
* for top:
** regnames: loop over all instances of a register
*** index
*** inst_name
*** type_name
*** array size (N, M) is kept in the pkg file
*** owning_addrmap.inst_name to get the register entity name

=== memories

* for mapfile: (!) arrays of memories as separate lines of mapfile
** memnames: loop over all instances of a memory
*** the BAR number (property of address map just below top)
*** the direct parent addrmap instance name (e.g. BSP or LLRF_FD)
*** number of elements (depth of memory), max 32?!
*** number of elements x4 regardless of the mem width (even an 8-bit element occupies 4 addresses)
*** width of an element (1-32?) -> memwidth property
*** addr: absolute_address minus the offset of the BAR
*** rw: either "RW" or "RO" (for now only "RW")
* for pkg file:
** n_memnames: goes to C_MEMNAMES -> pkg, top, adapter_axi4
** memtypes: UNUSED list of nodes with individual type_name
** memnames: loop over all instances of a memory
*** index
*** inst_name
*** addr: absolute_address minus the offset of the BAR
*** address width -> assume 32 bits = 4 addresses per memory width, not the actual size
* for top:
** memnames: loop over all instances of a memory
*** index
*** inst_name

=== external

* for mapfiles:
** extnames:
*** the direct parent addrmap instance name (e.g. BSP or LLRF_FD)
*** instance: either `node.inst_name` or `node.get_path_segment()`
*** total_words: number of 4 byte words
*** addr: absolute_address minus the offset of the BAR
*** addresses or ext.size: number of words x4
*** the BAR number (property of address map just below top)
*** width of an element (1-32?) always 32 for addrmaps, may be less for regfiles
*** rw: either "RW" or "RO" (for now only "RW")
* for pkg:
** n_extnames
** extnames: loop over all instances of a downstream interface
*** index
*** aw: address bits for 8 bit addressing
*** inst_name (name of record element)
* for top:
** n_extnames: for ifgtzero
** extnames: loop over all instances of a downstream interface
*** inst_name
*** index
* for adapter_axi4:
** n_extnames: for ifgtzero
** extnames: loop over all instances of a downstream interface

== Layout

* (instance: either `node.inst_name` or `node.get_path_segment()`)
* context
** node -> the AddrmapNode
** regtypes -> array(?) of RegNode
*** i
*** regtype -> RegNode with fields()
**** fields
*** type_name
** memtypes
** regnames
*** reg (add to context of each loop iteration)
** memnames
** extnames
*** i
*** ext (add to context of each loop iteration)
** addrmaps
** n_foo
